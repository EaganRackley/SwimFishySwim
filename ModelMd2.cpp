// ModelMd2.cpp
// Provides a class that can implement and perform 3d model translation, transformation, and rendering ...
// Author(s): Eagan Rackley
// Based on very helpful info and code samples contained in the following wiki entry: http://en.wikipedia.org/wiki/MD2_%28file_format%29

#include "SFSHeaders.h"
#include "ModelMd2.h"

// It's magical! (All md2 files have this number: IDP2)
#define MD2_MAGIC 0x32504449 

// This version should always be ta same...
#define	MD2_VERSION 8

// Maximum vertices allowed
#define MAX_MD2_VERTS 2048

// These define a normal table that we can access for generating light effects
Vector ModelMd2::myPreCalculatedNormals[NUMBER_OF_NORMALS] = {
{ -0.525731f,  0.000000f,  0.850651f }, 
{ -0.442863f,  0.238856f,  0.864188f }, 
{ -0.295242f,  0.000000f,  0.955423f }, 
{ -0.309017f,  0.500000f,  0.809017f }, 
{ -0.162460f,  0.262866f,  0.951056f }, 
{  0.000000f,  0.000000f,  1.000000f }, 
{  0.000000f,  0.850651f,  0.525731f }, 
{ -0.147621f,  0.716567f,  0.681718f }, 
{  0.147621f,  0.716567f,  0.681718f }, 
{  0.000000f,  0.525731f,  0.850651f }, 
{  0.309017f,  0.500000f,  0.809017f }, 
{  0.525731f,  0.000000f,  0.850651f }, 
{  0.295242f,  0.000000f,  0.955423f }, 
{  0.442863f,  0.238856f,  0.864188f }, 
{  0.162460f,  0.262866f,  0.951056f }, 
{ -0.681718f,  0.147621f,  0.716567f }, 
{ -0.809017f,  0.309017f,  0.500000f }, 
{ -0.587785f,  0.425325f,  0.688191f }, 
{ -0.850651f,  0.525731f,  0.000000f }, 
{ -0.864188f,  0.442863f,  0.238856f }, 
{ -0.716567f,  0.681718f,  0.147621f }, 
{ -0.688191f,  0.587785f,  0.425325f }, 
{ -0.500000f,  0.809017f,  0.309017f }, 
{ -0.238856f,  0.864188f,  0.442863f }, 
{ -0.425325f,  0.688191f,  0.587785f }, 
{ -0.716567f,  0.681718f, -0.147621f }, 
{ -0.500000f,  0.809017f, -0.309017f }, 
{ -0.525731f,  0.850651f,  0.000000f }, 
{  0.000000f,  0.850651f, -0.525731f }, 
{ -0.238856f,  0.864188f, -0.442863f }, 
{  0.000000f,  0.955423f, -0.295242f }, 
{ -0.262866f,  0.951056f, -0.162460f }, 
{  0.000000f,  1.000000f,  0.000000f }, 
{  0.000000f,  0.955423f,  0.295242f }, 
{ -0.262866f,  0.951056f,  0.162460f }, 
{  0.238856f,  0.864188f,  0.442863f }, 
{  0.262866f,  0.951056f,  0.162460f }, 
{  0.500000f,  0.809017f,  0.309017f }, 
{  0.238856f,  0.864188f, -0.442863f }, 
{  0.262866f,  0.951056f, -0.162460f }, 
{  0.500000f,  0.809017f, -0.309017f }, 
{  0.850651f,  0.525731f,  0.000000f }, 
{  0.716567f,  0.681718f,  0.147621f }, 
{  0.716567f,  0.681718f, -0.147621f }, 
{  0.525731f,  0.850651f,  0.000000f }, 
{  0.425325f,  0.688191f,  0.587785f }, 
{  0.864188f,  0.442863f,  0.238856f }, 
{  0.688191f,  0.587785f,  0.425325f }, 
{  0.809017f,  0.309017f,  0.500000f }, 
{  0.681718f,  0.147621f,  0.716567f }, 
{  0.587785f,  0.425325f,  0.688191f }, 
{  0.955423f,  0.295242f,  0.000000f }, 
{  1.000000f,  0.000000f,  0.000000f }, 
{  0.951056f,  0.162460f,  0.262866f }, 
{  0.850651f, -0.525731f,  0.000000f }, 
{  0.955423f, -0.295242f,  0.000000f }, 
{  0.864188f, -0.442863f,  0.238856f }, 
{  0.951056f, -0.162460f,  0.262866f }, 
{  0.809017f, -0.309017f,  0.500000f }, 
{  0.681718f, -0.147621f,  0.716567f }, 
{  0.850651f,  0.000000f,  0.525731f }, 
{  0.864188f,  0.442863f, -0.238856f }, 
{  0.809017f,  0.309017f, -0.500000f }, 
{  0.951056f,  0.162460f, -0.262866f }, 
{  0.525731f,  0.000000f, -0.850651f }, 
{  0.681718f,  0.147621f, -0.716567f }, 
{  0.681718f, -0.147621f, -0.716567f }, 
{  0.850651f,  0.000000f, -0.525731f }, 
{  0.809017f, -0.309017f, -0.500000f }, 
{  0.864188f, -0.442863f, -0.238856f }, 
{  0.951056f, -0.162460f, -0.262866f }, 
{  0.147621f,  0.716567f, -0.681718f }, 
{  0.309017f,  0.500000f, -0.809017f }, 
{  0.425325f,  0.688191f, -0.587785f }, 
{  0.442863f,  0.238856f, -0.864188f }, 
{  0.587785f,  0.425325f, -0.688191f }, 
{  0.688191f,  0.587785f, -0.425325f }, 
{ -0.147621f,  0.716567f, -0.681718f }, 
{ -0.309017f,  0.500000f, -0.809017f }, 
{  0.000000f,  0.525731f, -0.850651f }, 
{ -0.525731f,  0.000000f, -0.850651f }, 
{ -0.442863f,  0.238856f, -0.864188f }, 
{ -0.295242f,  0.000000f, -0.955423f }, 
{ -0.162460f,  0.262866f, -0.951056f }, 
{  0.000000f,  0.000000f, -1.000000f }, 
{  0.295242f,  0.000000f, -0.955423f }, 
{  0.162460f,  0.262866f, -0.951056f }, 
{ -0.442863f, -0.238856f, -0.864188f }, 
{ -0.309017f, -0.500000f, -0.809017f }, 
{ -0.162460f, -0.262866f, -0.951056f }, 
{  0.000000f, -0.850651f, -0.525731f }, 
{ -0.147621f, -0.716567f, -0.681718f }, 
{  0.147621f, -0.716567f, -0.681718f }, 
{  0.000000f, -0.525731f, -0.850651f }, 
{  0.309017f, -0.500000f, -0.809017f }, 
{  0.442863f, -0.238856f, -0.864188f }, 
{  0.162460f, -0.262866f, -0.951056f }, 
{  0.238856f, -0.864188f, -0.442863f }, 
{  0.500000f, -0.809017f, -0.309017f }, 
{  0.425325f, -0.688191f, -0.587785f }, 
{  0.716567f, -0.681718f, -0.147621f }, 
{  0.688191f, -0.587785f, -0.425325f }, 
{  0.587785f, -0.425325f, -0.688191f }, 
{  0.000000f, -0.955423f, -0.295242f }, 
{  0.000000f, -1.000000f,  0.000000f }, 
{  0.262866f, -0.951056f, -0.162460f }, 
{  0.000000f, -0.850651f,  0.525731f }, 
{  0.000000f, -0.955423f,  0.295242f }, 
{  0.238856f, -0.864188f,  0.442863f }, 
{  0.262866f, -0.951056f,  0.162460f }, 
{  0.500000f, -0.809017f,  0.309017f }, 
{  0.716567f, -0.681718f,  0.147621f }, 
{  0.525731f, -0.850651f,  0.000000f }, 
{ -0.238856f, -0.864188f, -0.442863f }, 
{ -0.500000f, -0.809017f, -0.309017f }, 
{ -0.262866f, -0.951056f, -0.162460f }, 
{ -0.850651f, -0.525731f,  0.000000f }, 
{ -0.716567f, -0.681718f, -0.147621f }, 
{ -0.716567f, -0.681718f,  0.147621f }, 
{ -0.525731f, -0.850651f,  0.000000f }, 
{ -0.500000f, -0.809017f,  0.309017f }, 
{ -0.238856f, -0.864188f,  0.442863f }, 
{ -0.262866f, -0.951056f,  0.162460f }, 
{ -0.864188f, -0.442863f,  0.238856f }, 
{ -0.809017f, -0.309017f,  0.500000f }, 
{ -0.688191f, -0.587785f,  0.425325f }, 
{ -0.681718f, -0.147621f,  0.716567f }, 
{ -0.442863f, -0.238856f,  0.864188f }, 
{ -0.587785f, -0.425325f,  0.688191f }, 
{ -0.309017f, -0.500000f,  0.809017f }, 
{ -0.147621f, -0.716567f,  0.681718f }, 
{ -0.425325f, -0.688191f,  0.587785f }, 
{ -0.162460f, -0.262866f,  0.951056f }, 
{  0.442863f, -0.238856f,  0.864188f }, 
{  0.162460f, -0.262866f,  0.951056f }, 
{  0.309017f, -0.500000f,  0.809017f }, 
{  0.147621f, -0.716567f,  0.681718f }, 
{  0.000000f, -0.525731f,  0.850651f }, 
{  0.425325f, -0.688191f,  0.587785f }, 
{  0.587785f, -0.425325f,  0.688191f }, 
{  0.688191f, -0.587785f,  0.425325f }, 
{ -0.955423f,  0.295242f,  0.000000f }, 
{ -0.951056f,  0.162460f,  0.262866f }, 
{ -1.000000f,  0.000000f,  0.000000f }, 
{ -0.850651f,  0.000000f,  0.525731f }, 
{ -0.955423f, -0.295242f,  0.000000f }, 
{ -0.951056f, -0.162460f,  0.262866f }, 
{ -0.864188f,  0.442863f, -0.238856f }, 
{ -0.951056f,  0.162460f, -0.262866f }, 
{ -0.809017f,  0.309017f, -0.500000f }, 
{ -0.864188f, -0.442863f, -0.238856f }, 
{ -0.951056f, -0.162460f, -0.262866f }, 
{ -0.809017f, -0.309017f, -0.500000f }, 
{ -0.681718f,  0.147621f, -0.716567f }, 
{ -0.681718f, -0.147621f, -0.716567f }, 
{ -0.850651f,  0.000000f, -0.525731f }, 
{ -0.688191f,  0.587785f, -0.425325f }, 
{ -0.587785f,  0.425325f, -0.688191f }, 
{ -0.425325f,  0.688191f, -0.587785f }, 
{ -0.425325f, -0.688191f, -0.587785f }, 
{ -0.587785f, -0.425325f, -0.688191f }, 
{ -0.688191f, -0.587785f, -0.425325f }
};

// Some precalculated results of dot products - will save us a *ton* of processing time :D
float ModelMd2::preCalculatedDotProdcuts[NUMBER_OF_DOT_PRODUCTS][256] = {
{ 1.23f, 1.30f, 1.47f, 1.35f, 1.56f, 1.71f, 1.37f, 1.38f, 1.59f, 1.60f, 1.79f, 1.97f, 1.88f, 1.92f, 1.79f, 1.02f, 0.93f, 1.07f, 0.82f, 0.87f, 0.88f, 0.94f, 0.96f, 1.14f, 1.11f, 0.82f, 0.83f, 0.89f, 0.89f, 0.86f, 0.94f, 0.91f, 1.00f, 1.21f, 0.98f, 1.48f, 1.30f, 1.57f, 0.96f, 1.07f, 1.14f, 1.60f, 1.61f, 1.40f, 1.37f, 1.72f, 1.78f, 1.79f, 1.93f, 1.99f, 1.90f, 1.68f, 1.71f, 1.86f, 1.60f, 1.68f, 1.78f, 1.86f, 1.93f, 1.99f, 1.97f, 1.44f, 1.22f, 1.49f, 0.93f, 0.99f, 0.99f, 1.23f, 1.22f, 1.44f, 1.49f, 0.89f, 0.89f, 0.97f, 0.91f, 0.98f, 1.19f, 0.82f, 0.76f, 0.82f, 0.71f, 0.72f, 0.73f, 0.76f, 0.79f, 0.86f, 0.83f, 0.72f, 0.76f, 0.76f, 0.89f, 0.82f, 0.89f, 0.82f, 0.89f, 0.91f, 0.83f, 0.96f, 1.14f, 0.97f, 1.40f, 1.19f, 0.98f, 0.94f, 1.00f, 1.07f, 1.37f, 1.21f, 1.48f, 1.30f, 1.57f, 1.61f, 1.37f, 0.86f, 0.83f, 0.91f, 0.82f, 0.82f, 0.88f, 0.89f, 0.96f, 1.14f, 0.98f, 0.87f, 0.93f, 0.94f, 1.02f, 1.30f, 1.07f, 1.35f, 1.38f, 1.11f, 1.56f, 1.92f, 1.79f, 1.79f, 1.59f, 1.60f, 1.72f, 1.90f, 1.79f, 0.80f, 0.85f, 0.79f, 0.93f, 0.80f, 0.85f, 0.77f, 0.74f, 0.72f, 0.77f, 0.74f, 0.72f, 0.70f, 0.70f, 0.71f, 0.76f, 0.73f, 0.79f, 0.79f, 0.73f, 0.76f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f },
{ 1.26f, 1.26f, 1.48f, 1.23f, 1.50f, 1.71f, 1.14f, 1.19f, 1.38f, 1.46f, 1.64f, 1.94f, 1.87f, 1.84f, 1.71f, 1.02f, 0.92f, 1.00f, 0.79f, 0.85f, 0.84f, 0.91f, 0.90f, 0.98f, 0.99f, 0.77f, 0.77f, 0.83f, 0.82f, 0.79f, 0.86f, 0.84f, 0.92f, 0.99f, 0.91f, 1.24f, 1.03f, 1.33f, 0.88f, 0.94f, 0.97f, 1.41f, 1.39f, 1.18f, 1.11f, 1.51f, 1.61f, 1.59f, 1.80f, 1.91f, 1.76f, 1.54f, 1.65f, 1.76f, 1.70f, 1.70f, 1.85f, 1.85f, 1.97f, 1.99f, 1.93f, 1.28f, 1.09f, 1.39f, 0.92f, 0.97f, 0.99f, 1.18f, 1.26f, 1.52f, 1.48f, 0.83f, 0.85f, 0.90f, 0.88f, 0.93f, 1.00f, 0.77f, 0.73f, 0.78f, 0.72f, 0.71f, 0.74f, 0.75f, 0.79f, 0.86f, 0.81f, 0.75f, 0.81f, 0.79f, 0.96f, 0.88f, 0.94f, 0.86f, 0.93f, 0.92f, 0.85f, 1.08f, 1.33f, 1.05f, 1.55f, 1.31f, 1.01f, 1.05f, 1.27f, 1.31f, 1.60f, 1.47f, 1.70f, 1.54f, 1.76f, 1.76f, 1.57f, 0.93f, 0.90f, 0.99f, 0.88f, 0.88f, 0.95f, 0.97f, 1.11f, 1.39f, 1.20f, 0.92f, 0.97f, 1.01f, 1.10f, 1.39f, 1.22f, 1.51f, 1.58f, 1.32f, 1.64f, 1.97f, 1.85f, 1.91f, 1.77f, 1.74f, 1.88f, 1.99f, 1.91f, 0.79f, 0.86f, 0.80f, 0.94f, 0.84f, 0.88f, 0.74f, 0.74f, 0.71f, 0.82f, 0.77f, 0.76f, 0.70f, 0.73f, 0.72f, 0.73f, 0.70f, 0.74f, 0.85f, 0.77f, 0.82f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f },
{ 1.34f, 1.27f, 1.53f, 1.17f, 1.46f, 1.71f, 0.98f, 1.05f, 1.20f, 1.34f, 1.48f, 1.86f, 1.82f, 1.71f, 1.62f, 1.09f, 0.94f, 0.99f, 0.79f, 0.85f, 0.82f, 0.90f, 0.87f, 0.93f, 0.96f, 0.76f, 0.74f, 0.79f, 0.76f, 0.74f, 0.79f, 0.78f, 0.85f, 0.92f, 0.85f, 1.00f, 0.93f, 1.06f, 0.81f, 0.86f, 0.89f, 1.16f, 1.12f, 0.97f, 0.95f, 1.28f, 1.38f, 1.35f, 1.60f, 1.77f, 1.57f, 1.33f, 1.50f, 1.58f, 1.69f, 1.63f, 1.82f, 1.74f, 1.91f, 1.92f, 1.80f, 1.04f, 0.97f, 1.21f, 0.90f, 0.93f, 0.97f, 1.05f, 1.21f, 1.48f, 1.37f, 0.77f, 0.80f, 0.84f, 0.85f, 0.88f, 0.92f, 0.73f, 0.71f, 0.74f, 0.74f, 0.71f, 0.75f, 0.73f, 0.79f, 0.84f, 0.78f, 0.79f, 0.86f, 0.81f, 1.05f, 0.94f, 0.99f, 0.90f, 0.95f, 0.92f, 0.86f, 1.24f, 1.44f, 1.14f, 1.59f, 1.34f, 1.02f, 1.27f, 1.50f, 1.49f, 1.80f, 1.69f, 1.86f, 1.72f, 1.87f, 1.80f, 1.69f, 1.00f, 0.98f, 1.23f, 0.95f, 0.96f, 1.09f, 1.16f, 1.37f, 1.63f, 1.46f, 0.99f, 1.10f, 1.25f, 1.24f, 1.51f, 1.41f, 1.67f, 1.77f, 1.55f, 1.72f, 1.95f, 1.89f, 1.98f, 1.91f, 1.86f, 1.97f, 1.99f, 1.94f, 0.81f, 0.89f, 0.85f, 0.98f, 0.90f, 0.94f, 0.75f, 0.78f, 0.73f, 0.89f, 0.83f, 0.82f, 0.72f, 0.77f, 0.76f, 0.72f, 0.70f, 0.71f, 0.91f, 0.83f, 0.89f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f },
{ 1.46f, 1.34f, 1.60f, 1.16f, 1.46f, 1.71f, 0.94f, 0.99f, 1.05f, 1.26f, 1.33f, 1.74f, 1.76f, 1.57f, 1.54f, 1.23f, 0.98f, 1.05f, 0.83f, 0.89f, 0.84f, 0.92f, 0.87f, 0.91f, 0.96f, 0.78f, 0.74f, 0.79f, 0.72f, 0.72f, 0.75f, 0.76f, 0.80f, 0.88f, 0.83f, 0.94f, 0.87f, 0.95f, 0.76f, 0.80f, 0.82f, 0.97f, 0.96f, 0.89f, 0.88f, 1.08f, 1.11f, 1.10f, 1.37f, 1.59f, 1.37f, 1.07f, 1.27f, 1.34f, 1.57f, 1.45f, 1.69f, 1.55f, 1.77f, 1.79f, 1.60f, 0.93f, 0.90f, 0.99f, 0.86f, 0.87f, 0.93f, 0.96f, 1.07f, 1.35f, 1.18f, 0.73f, 0.76f, 0.77f, 0.81f, 0.82f, 0.85f, 0.70f, 0.71f, 0.72f, 0.78f, 0.73f, 0.77f, 0.73f, 0.79f, 0.82f, 0.76f, 0.83f, 0.90f, 0.84f, 1.18f, 0.98f, 1.03f, 0.92f, 0.95f, 0.90f, 0.86f, 1.32f, 1.45f, 1.15f, 1.53f, 1.27f, 0.99f, 1.42f, 1.65f, 1.58f, 1.93f, 1.83f, 1.94f, 1.81f, 1.88f, 1.74f, 1.70f, 1.19f, 1.17f, 1.44f, 1.11f, 1.15f, 1.36f, 1.41f, 1.61f, 1.81f, 1.67f, 1.22f, 1.34f, 1.50f, 1.42f, 1.65f, 1.61f, 1.82f, 1.91f, 1.75f, 1.80f, 1.89f, 1.89f, 1.98f, 1.99f, 1.94f, 1.98f, 1.92f, 1.87f, 0.86f, 0.95f, 0.92f, 1.14f, 0.98f, 1.03f, 0.79f, 0.84f, 0.77f, 0.97f, 0.90f, 0.89f, 0.76f, 0.82f, 0.82f, 0.74f, 0.72f, 0.71f, 0.98f, 0.89f, 0.97f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f },
{ 1.60f, 1.44f, 1.68f, 1.22f, 1.49f, 1.71f, 0.93f, 0.99f, 0.99f, 1.23f, 1.22f, 1.60f, 1.68f, 1.44f, 1.49f, 1.40f, 1.14f, 1.19f, 0.89f, 0.96f, 0.89f, 0.97f, 0.89f, 0.91f, 0.98f, 0.82f, 0.76f, 0.82f, 0.71f, 0.72f, 0.73f, 0.76f, 0.79f, 0.86f, 0.83f, 0.91f, 0.83f, 0.89f, 0.72f, 0.76f, 0.76f, 0.89f, 0.89f, 0.82f, 0.82f, 0.98f, 0.96f, 0.97f, 1.14f, 1.40f, 1.19f, 0.94f, 1.00f, 1.07f, 1.37f, 1.21f, 1.48f, 1.30f, 1.57f, 1.61f, 1.37f, 0.86f, 0.83f, 0.91f, 0.82f, 0.82f, 0.88f, 0.89f, 0.96f, 1.14f, 0.98f, 0.70f, 0.72f, 0.73f, 0.77f, 0.76f, 0.79f, 0.70f, 0.72f, 0.71f, 0.82f, 0.77f, 0.80f, 0.74f, 0.79f, 0.80f, 0.74f, 0.87f, 0.93f, 0.85f, 1.23f, 1.02f, 1.02f, 0.93f, 0.93f, 0.87f, 0.85f, 1.30f, 1.35f, 1.07f, 1.38f, 1.11f, 0.94f, 1.47f, 1.71f, 1.56f, 1.97f, 1.88f, 1.92f, 1.79f, 1.79f, 1.59f, 1.60f, 1.30f, 1.35f, 1.56f, 1.37f, 1.38f, 1.59f, 1.60f, 1.79f, 1.92f, 1.79f, 1.48f, 1.57f, 1.72f, 1.61f, 1.78f, 1.79f, 1.93f, 1.99f, 1.90f, 1.86f, 1.78f, 1.86f, 1.93f, 1.99f, 1.97f, 1.90f, 1.79f, 1.72f, 0.94f, 1.07f, 1.00f, 1.37f, 1.21f, 1.30f, 0.86f, 0.91f, 0.83f, 1.14f, 0.98f, 0.96f, 0.82f, 0.88f, 0.89f, 0.79f, 0.76f, 0.73f, 1.07f, 0.94f, 1.11f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f },
{ 1.74f, 1.57f, 1.76f, 1.33f, 1.54f, 1.71f, 0.94f, 1.05f, 0.99f, 1.26f, 1.16f, 1.46f, 1.60f, 1.34f, 1.46f, 1.59f, 1.37f, 1.37f, 0.97f, 1.11f, 0.96f, 1.10f, 0.95f, 0.94f, 1.08f, 0.89f, 0.82f, 0.88f, 0.72f, 0.76f, 0.75f, 0.80f, 0.80f, 0.88f, 0.87f, 0.91f, 0.83f, 0.87f, 0.72f, 0.76f, 0.74f, 0.83f, 0.84f, 0.78f, 0.79f, 0.96f, 0.89f, 0.92f, 0.98f, 1.23f, 1.05f, 0.86f, 0.92f, 0.95f, 1.11f, 0.98f, 1.22f, 1.03f, 1.34f, 1.42f, 1.14f, 0.79f, 0.77f, 0.84f, 0.78f, 0.76f, 0.82f, 0.82f, 0.89f, 0.97f, 0.90f, 0.70f, 0.71f, 0.71f, 0.73f, 0.72f, 0.74f, 0.73f, 0.76f, 0.72f, 0.86f, 0.81f, 0.82f, 0.76f, 0.79f, 0.77f, 0.73f, 0.90f, 0.95f, 0.86f, 1.18f, 1.03f, 0.98f, 0.92f, 0.90f, 0.83f, 0.84f, 1.19f, 1.17f, 0.98f, 1.15f, 0.97f, 0.89f, 1.42f, 1.65f, 1.44f, 1.93f, 1.83f, 1.81f, 1.67f, 1.61f, 1.36f, 1.41f, 1.32f, 1.45f, 1.58f, 1.57f, 1.53f, 1.74f, 1.70f, 1.88f, 1.94f, 1.81f, 1.69f, 1.77f, 1.87f, 1.79f, 1.89f, 1.92f, 1.98f, 1.99f, 1.98f, 1.89f, 1.65f, 1.80f, 1.82f, 1.91f, 1.94f, 1.75f, 1.61f, 1.50f, 1.07f, 1.34f, 1.27f, 1.60f, 1.45f, 1.55f, 0.93f, 0.99f, 0.90f, 1.35f, 1.18f, 1.07f, 0.87f, 0.93f, 0.96f, 0.85f, 0.82f, 0.77f, 1.15f, 0.99f, 1.27f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f },
{ 1.86f, 1.71f, 1.82f, 1.48f, 1.62f, 1.71f, 0.98f, 1.20f, 1.05f, 1.34f, 1.17f, 1.34f, 1.53f, 1.27f, 1.46f, 1.77f, 1.60f, 1.57f, 1.16f, 1.38f, 1.12f, 1.35f, 1.06f, 1.00f, 1.28f, 0.97f, 0.89f, 0.95f, 0.76f, 0.81f, 0.79f, 0.86f, 0.85f, 0.92f, 0.93f, 0.93f, 0.85f, 0.87f, 0.74f, 0.78f, 0.74f, 0.79f, 0.82f, 0.76f, 0.79f, 0.96f, 0.85f, 0.90f, 0.94f, 1.09f, 0.99f, 0.81f, 0.85f, 0.89f, 0.95f, 0.90f, 0.99f, 0.94f, 1.10f, 1.24f, 0.98f, 0.75f, 0.73f, 0.78f, 0.74f, 0.72f, 0.77f, 0.76f, 0.82f, 0.89f, 0.83f, 0.73f, 0.71f, 0.71f, 0.71f, 0.70f, 0.72f, 0.77f, 0.80f, 0.74f, 0.90f, 0.85f, 0.84f, 0.78f, 0.79f, 0.75f, 0.73f, 0.92f, 0.95f, 0.86f, 1.05f, 0.99f, 0.94f, 0.90f, 0.86f, 0.79f, 0.81f, 1.00f, 0.98f, 0.91f, 0.96f, 0.89f, 0.83f, 1.27f, 1.50f, 1.23f, 1.80f, 1.69f, 1.63f, 1.46f, 1.37f, 1.09f, 1.16f, 1.24f, 1.44f, 1.49f, 1.69f, 1.59f, 1.80f, 1.69f, 1.87f, 1.86f, 1.72f, 1.82f, 1.91f, 1.94f, 1.92f, 1.95f, 1.99f, 1.98f, 1.91f, 1.97f, 1.89f, 1.51f, 1.72f, 1.67f, 1.77f, 1.86f, 1.55f, 1.41f, 1.25f, 1.33f, 1.58f, 1.50f, 1.80f, 1.63f, 1.74f, 1.04f, 1.21f, 0.97f, 1.48f, 1.37f, 1.21f, 0.93f, 0.97f, 1.05f, 0.92f, 0.88f, 0.84f, 1.14f, 1.02f, 1.34f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f },
{ 1.94f, 1.84f, 1.87f, 1.64f, 1.71f, 1.71f, 1.14f, 1.38f, 1.19f, 1.46f, 1.23f, 1.26f, 1.48f, 1.26f, 1.50f, 1.91f, 1.80f, 1.76f, 1.41f, 1.61f, 1.39f, 1.59f, 1.33f, 1.24f, 1.51f, 1.18f, 0.97f, 1.11f, 0.82f, 0.88f, 0.86f, 0.94f, 0.92f, 0.99f, 1.03f, 0.98f, 0.91f, 0.90f, 0.79f, 0.84f, 0.77f, 0.79f, 0.84f, 0.77f, 0.83f, 0.99f, 0.85f, 0.91f, 0.92f, 1.02f, 1.00f, 0.79f, 0.80f, 0.86f, 0.88f, 0.84f, 0.92f, 0.88f, 0.97f, 1.10f, 0.94f, 0.74f, 0.71f, 0.74f, 0.72f, 0.70f, 0.73f, 0.72f, 0.76f, 0.82f, 0.77f, 0.77f, 0.73f, 0.74f, 0.71f, 0.70f, 0.73f, 0.83f, 0.85f, 0.78f, 0.92f, 0.88f, 0.86f, 0.81f, 0.79f, 0.74f, 0.75f, 0.92f, 0.93f, 0.85f, 0.96f, 0.94f, 0.88f, 0.86f, 0.81f, 0.75f, 0.79f, 0.93f, 0.90f, 0.85f, 0.88f, 0.82f, 0.77f, 1.05f, 1.27f, 0.99f, 1.60f, 1.47f, 1.39f, 1.20f, 1.11f, 0.95f, 0.97f, 1.08f, 1.33f, 1.31f, 1.70f, 1.55f, 1.76f, 1.57f, 1.76f, 1.70f, 1.54f, 1.85f, 1.97f, 1.91f, 1.99f, 1.97f, 1.99f, 1.91f, 1.77f, 1.88f, 1.85f, 1.39f, 1.64f, 1.51f, 1.58f, 1.74f, 1.32f, 1.22f, 1.01f, 1.54f, 1.76f, 1.65f, 1.93f, 1.70f, 1.85f, 1.28f, 1.39f, 1.09f, 1.52f, 1.48f, 1.26f, 0.97f, 0.99f, 1.18f, 1.00f, 0.93f, 0.90f, 1.05f, 1.01f, 1.31f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f },
{ 1.97f, 1.92f, 1.88f, 1.79f, 1.79f, 1.71f, 1.37f, 1.59f, 1.38f, 1.60f, 1.35f, 1.23f, 1.47f, 1.30f, 1.56f, 1.99f, 1.93f, 1.90f, 1.60f, 1.78f, 1.61f, 1.79f, 1.57f, 1.48f, 1.72f, 1.40f, 1.14f, 1.37f, 0.89f, 0.96f, 0.94f, 1.07f, 1.00f, 1.21f, 1.30f, 1.14f, 0.98f, 0.96f, 0.86f, 0.91f, 0.83f, 0.82f, 0.88f, 0.82f, 0.89f, 1.11f, 0.87f, 0.94f, 0.93f, 1.02f, 1.07f, 0.80f, 0.79f, 0.85f, 0.82f, 0.80f, 0.87f, 0.85f, 0.93f, 1.02f, 0.93f, 0.77f, 0.72f, 0.74f, 0.71f, 0.70f, 0.70f, 0.71f, 0.72f, 0.77f, 0.74f, 0.82f, 0.76f, 0.79f, 0.72f, 0.73f, 0.76f, 0.89f, 0.89f, 0.82f, 0.93f, 0.91f, 0.86f, 0.83f, 0.79f, 0.73f, 0.76f, 0.91f, 0.89f, 0.83f, 0.89f, 0.89f, 0.82f, 0.82f, 0.76f, 0.72f, 0.76f, 0.86f, 0.83f, 0.79f, 0.82f, 0.76f, 0.73f, 0.94f, 1.00f, 0.91f, 1.37f, 1.21f, 1.14f, 0.98f, 0.96f, 0.88f, 0.89f, 0.96f, 1.14f, 1.07f, 1.60f, 1.40f, 1.61f, 1.37f, 1.57f, 1.48f, 1.30f, 1.78f, 1.93f, 1.79f, 1.99f, 1.92f, 1.90f, 1.79f, 1.59f, 1.72f, 1.79f, 1.30f, 1.56f, 1.35f, 1.38f, 1.60f, 1.11f, 1.07f, 0.94f, 1.68f, 1.86f, 1.71f, 1.97f, 1.68f, 1.86f, 1.44f, 1.49f, 1.22f, 1.44f, 1.49f, 1.22f, 0.99f, 0.99f, 1.23f, 1.19f, 0.98f, 0.97f, 0.97f, 0.98f, 1.19f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f },
{ 1.94f, 1.97f, 1.87f, 1.91f, 1.85f, 1.71f, 1.60f, 1.77f, 1.58f, 1.74f, 1.51f, 1.26f, 1.48f, 1.39f, 1.64f, 1.99f, 1.97f, 1.99f, 1.70f, 1.85f, 1.76f, 1.91f, 1.76f, 1.70f, 1.88f, 1.55f, 1.33f, 1.57f, 0.96f, 1.08f, 1.05f, 1.31f, 1.27f, 1.47f, 1.54f, 1.39f, 1.20f, 1.11f, 0.93f, 0.99f, 0.90f, 0.88f, 0.95f, 0.88f, 0.97f, 1.32f, 0.92f, 1.01f, 0.97f, 1.10f, 1.22f, 0.84f, 0.80f, 0.88f, 0.79f, 0.79f, 0.85f, 0.86f, 0.92f, 1.02f, 0.94f, 0.82f, 0.76f, 0.77f, 0.72f, 0.73f, 0.70f, 0.72f, 0.71f, 0.74f, 0.74f, 0.88f, 0.81f, 0.85f, 0.75f, 0.77f, 0.82f, 0.94f, 0.93f, 0.86f, 0.92f, 0.92f, 0.86f, 0.85f, 0.79f, 0.74f, 0.79f, 0.88f, 0.85f, 0.81f, 0.82f, 0.83f, 0.77f, 0.78f, 0.73f, 0.71f, 0.75f, 0.79f, 0.77f, 0.74f, 0.77f, 0.73f, 0.70f, 0.86f, 0.92f, 0.84f, 1.14f, 0.99f, 0.98f, 0.91f, 0.90f, 0.84f, 0.83f, 0.88f, 0.97f, 0.94f, 1.41f, 1.18f, 1.39f, 1.11f, 1.33f, 1.24f, 1.03f, 1.61f, 1.80f, 1.59f, 1.91f, 1.84f, 1.76f, 1.64f, 1.38f, 1.51f, 1.71f, 1.26f, 1.50f, 1.23f, 1.19f, 1.46f, 0.99f, 1.00f, 0.91f, 1.70f, 1.85f, 1.65f, 1.93f, 1.54f, 1.76f, 1.52f, 1.48f, 1.26f, 1.28f, 1.39f, 1.09f, 0.99f, 0.97f, 1.18f, 1.31f, 1.01f, 1.05f, 0.90f, 0.93f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f },
{ 1.86f, 1.95f, 1.82f, 1.98f, 1.89f, 1.71f, 1.80f, 1.91f, 1.77f, 1.86f, 1.67f, 1.34f, 1.53f, 1.51f, 1.72f, 1.92f, 1.91f, 1.99f, 1.69f, 1.82f, 1.80f, 1.94f, 1.87f, 1.86f, 1.97f, 1.59f, 1.44f, 1.69f, 1.05f, 1.24f, 1.27f, 1.49f, 1.50f, 1.69f, 1.72f, 1.63f, 1.46f, 1.37f, 1.00f, 1.23f, 0.98f, 0.95f, 1.09f, 0.96f, 1.16f, 1.55f, 0.99f, 1.25f, 1.10f, 1.24f, 1.41f, 0.90f, 0.85f, 0.94f, 0.79f, 0.81f, 0.85f, 0.89f, 0.94f, 1.09f, 0.98f, 0.89f, 0.82f, 0.83f, 0.74f, 0.77f, 0.72f, 0.76f, 0.73f, 0.75f, 0.78f, 0.94f, 0.86f, 0.91f, 0.79f, 0.83f, 0.89f, 0.99f, 0.95f, 0.90f, 0.90f, 0.92f, 0.84f, 0.86f, 0.79f, 0.75f, 0.81f, 0.85f, 0.80f, 0.78f, 0.76f, 0.77f, 0.73f, 0.74f, 0.71f, 0.71f, 0.73f, 0.74f, 0.74f, 0.71f, 0.76f, 0.72f, 0.70f, 0.79f, 0.85f, 0.78f, 0.98f, 0.92f, 0.93f, 0.85f, 0.87f, 0.82f, 0.79f, 0.81f, 0.89f, 0.86f, 1.16f, 0.97f, 1.12f, 0.95f, 1.06f, 1.00f, 0.93f, 1.38f, 1.60f, 1.35f, 1.77f, 1.71f, 1.57f, 1.48f, 1.20f, 1.28f, 1.62f, 1.27f, 1.46f, 1.17f, 1.05f, 1.34f, 0.96f, 0.99f, 0.90f, 1.63f, 1.74f, 1.50f, 1.80f, 1.33f, 1.58f, 1.48f, 1.37f, 1.21f, 1.04f, 1.21f, 0.97f, 0.97f, 0.93f, 1.05f, 1.34f, 1.02f, 1.14f, 0.84f, 0.88f, 0.92f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f },
{ 1.74f, 1.89f, 1.76f, 1.98f, 1.89f, 1.71f, 1.93f, 1.99f, 1.91f, 1.94f, 1.82f, 1.46f, 1.60f, 1.65f, 1.80f, 1.79f, 1.77f, 1.92f, 1.57f, 1.69f, 1.74f, 1.87f, 1.88f, 1.94f, 1.98f, 1.53f, 1.45f, 1.70f, 1.18f, 1.32f, 1.42f, 1.58f, 1.65f, 1.83f, 1.81f, 1.81f, 1.67f, 1.61f, 1.19f, 1.44f, 1.17f, 1.11f, 1.36f, 1.15f, 1.41f, 1.75f, 1.22f, 1.50f, 1.34f, 1.42f, 1.61f, 0.98f, 0.92f, 1.03f, 0.83f, 0.86f, 0.89f, 0.95f, 0.98f, 1.23f, 1.14f, 0.97f, 0.89f, 0.90f, 0.78f, 0.82f, 0.76f, 0.82f, 0.77f, 0.79f, 0.84f, 0.98f, 0.90f, 0.98f, 0.83f, 0.89f, 0.97f, 1.03f, 0.95f, 0.92f, 0.86f, 0.90f, 0.82f, 0.86f, 0.79f, 0.77f, 0.84f, 0.81f, 0.76f, 0.76f, 0.72f, 0.73f, 0.70f, 0.72f, 0.71f, 0.73f, 0.73f, 0.72f, 0.74f, 0.71f, 0.78f, 0.74f, 0.72f, 0.75f, 0.80f, 0.76f, 0.94f, 0.88f, 0.91f, 0.83f, 0.87f, 0.84f, 0.79f, 0.76f, 0.82f, 0.80f, 0.97f, 0.89f, 0.96f, 0.88f, 0.95f, 0.94f, 0.87f, 1.11f, 1.37f, 1.10f, 1.59f, 1.57f, 1.37f, 1.33f, 1.05f, 1.08f, 1.54f, 1.34f, 1.46f, 1.16f, 0.99f, 1.26f, 0.96f, 1.05f, 0.92f, 1.45f, 1.55f, 1.27f, 1.60f, 1.07f, 1.34f, 1.35f, 1.18f, 1.07f, 0.93f, 0.99f, 0.90f, 0.93f, 0.87f, 0.96f, 1.27f, 0.99f, 1.15f, 0.77f, 0.82f, 0.85f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f },
{ 1.60f, 1.78f, 1.68f, 1.93f, 1.86f, 1.71f, 1.97f, 1.99f, 1.99f, 1.97f, 1.93f, 1.60f, 1.68f, 1.78f, 1.86f, 1.61f, 1.57f, 1.79f, 1.37f, 1.48f, 1.59f, 1.72f, 1.79f, 1.92f, 1.90f, 1.38f, 1.35f, 1.60f, 1.23f, 1.30f, 1.47f, 1.56f, 1.71f, 1.88f, 1.79f, 1.92f, 1.79f, 1.79f, 1.30f, 1.56f, 1.35f, 1.37f, 1.59f, 1.38f, 1.60f, 1.90f, 1.48f, 1.72f, 1.57f, 1.61f, 1.79f, 1.21f, 1.00f, 1.30f, 0.89f, 0.94f, 0.96f, 1.07f, 1.14f, 1.40f, 1.37f, 1.14f, 0.96f, 0.98f, 0.82f, 0.88f, 0.82f, 0.89f, 0.83f, 0.86f, 0.91f, 1.02f, 0.93f, 1.07f, 0.87f, 0.94f, 1.11f, 1.02f, 0.93f, 0.93f, 0.82f, 0.87f, 0.80f, 0.85f, 0.79f, 0.80f, 0.85f, 0.77f, 0.72f, 0.74f, 0.71f, 0.70f, 0.70f, 0.71f, 0.72f, 0.77f, 0.74f, 0.72f, 0.76f, 0.73f, 0.82f, 0.79f, 0.76f, 0.73f, 0.79f, 0.76f, 0.93f, 0.86f, 0.91f, 0.83f, 0.89f, 0.89f, 0.82f, 0.72f, 0.76f, 0.76f, 0.89f, 0.82f, 0.89f, 0.82f, 0.89f, 0.91f, 0.83f, 0.96f, 1.14f, 0.97f, 1.40f, 1.44f, 1.19f, 1.22f, 0.99f, 0.98f, 1.49f, 1.44f, 1.49f, 1.22f, 0.99f, 1.23f, 0.98f, 1.19f, 0.97f, 1.21f, 1.30f, 1.00f, 1.37f, 0.94f, 1.07f, 1.14f, 0.98f, 0.96f, 0.86f, 0.91f, 0.83f, 0.88f, 0.82f, 0.89f, 1.11f, 0.94f, 1.07f, 0.73f, 0.76f, 0.79f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f },
{ 1.46f, 1.65f, 1.60f, 1.82f, 1.80f, 1.71f, 1.93f, 1.91f, 1.99f, 1.94f, 1.98f, 1.74f, 1.76f, 1.89f, 1.89f, 1.42f, 1.34f, 1.61f, 1.11f, 1.22f, 1.36f, 1.50f, 1.61f, 1.81f, 1.75f, 1.15f, 1.17f, 1.41f, 1.18f, 1.19f, 1.42f, 1.44f, 1.65f, 1.83f, 1.67f, 1.94f, 1.81f, 1.88f, 1.32f, 1.58f, 1.45f, 1.57f, 1.74f, 1.53f, 1.70f, 1.98f, 1.69f, 1.87f, 1.77f, 1.79f, 1.92f, 1.45f, 1.27f, 1.55f, 0.97f, 1.07f, 1.11f, 1.34f, 1.37f, 1.59f, 1.60f, 1.35f, 1.07f, 1.18f, 0.86f, 0.93f, 0.87f, 0.96f, 0.90f, 0.93f, 0.99f, 1.03f, 0.95f, 1.15f, 0.90f, 0.99f, 1.27f, 0.98f, 0.90f, 0.92f, 0.78f, 0.83f, 0.77f, 0.84f, 0.79f, 0.82f, 0.86f, 0.73f, 0.71f, 0.73f, 0.72f, 0.70f, 0.73f, 0.72f, 0.76f, 0.81f, 0.76f, 0.76f, 0.82f, 0.77f, 0.89f, 0.85f, 0.82f, 0.75f, 0.80f, 0.80f, 0.94f, 0.88f, 0.94f, 0.87f, 0.95f, 0.96f, 0.88f, 0.72f, 0.74f, 0.76f, 0.83f, 0.78f, 0.84f, 0.79f, 0.87f, 0.91f, 0.83f, 0.89f, 0.98f, 0.92f, 1.23f, 1.34f, 1.05f, 1.16f, 0.99f, 0.96f, 1.46f, 1.57f, 1.54f, 1.33f, 1.05f, 1.26f, 1.08f, 1.37f, 1.10f, 0.98f, 1.03f, 0.92f, 1.14f, 0.86f, 0.95f, 0.97f, 0.90f, 0.89f, 0.79f, 0.84f, 0.77f, 0.82f, 0.76f, 0.82f, 0.97f, 0.89f, 0.98f, 0.71f, 0.72f, 0.74f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f },
{ 1.34f, 1.51f, 1.53f, 1.67f, 1.72f, 1.71f, 1.80f, 1.77f, 1.91f, 1.86f, 1.98f, 1.86f, 1.82f, 1.95f, 1.89f, 1.24f, 1.10f, 1.41f, 0.95f, 0.99f, 1.09f, 1.25f, 1.37f, 1.63f, 1.55f, 0.96f, 0.98f, 1.16f, 1.05f, 1.00f, 1.27f, 1.23f, 1.50f, 1.69f, 1.46f, 1.86f, 1.72f, 1.87f, 1.24f, 1.49f, 1.44f, 1.69f, 1.80f, 1.59f, 1.69f, 1.97f, 1.82f, 1.94f, 1.91f, 1.92f, 1.99f, 1.63f, 1.50f, 1.74f, 1.16f, 1.33f, 1.38f, 1.58f, 1.60f, 1.77f, 1.80f, 1.48f, 1.21f, 1.37f, 0.90f, 0.97f, 0.93f, 1.05f, 0.97f, 1.04f, 1.21f, 0.99f, 0.95f, 1.14f, 0.92f, 1.02f, 1.34f, 0.94f, 0.86f, 0.90f, 0.74f, 0.79f, 0.75f, 0.81f, 0.79f, 0.84f, 0.86f, 0.71f, 0.71f, 0.73f, 0.76f, 0.73f, 0.77f, 0.74f, 0.80f, 0.85f, 0.78f, 0.81f, 0.89f, 0.84f, 0.97f, 0.92f, 0.88f, 0.79f, 0.85f, 0.86f, 0.98f, 0.92f, 1.00f, 0.93f, 1.06f, 1.12f, 0.95f, 0.74f, 0.74f, 0.78f, 0.79f, 0.76f, 0.82f, 0.79f, 0.87f, 0.93f, 0.85f, 0.85f, 0.94f, 0.90f, 1.09f, 1.27f, 0.99f, 1.17f, 1.05f, 0.96f, 1.46f, 1.71f, 1.62f, 1.48f, 1.20f, 1.34f, 1.28f, 1.57f, 1.35f, 0.90f, 0.94f, 0.85f, 0.98f, 0.81f, 0.89f, 0.89f, 0.83f, 0.82f, 0.75f, 0.78f, 0.73f, 0.77f, 0.72f, 0.76f, 0.89f, 0.83f, 0.91f, 0.71f, 0.70f, 0.72f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f },
{ 1.26f, 1.39f, 1.48f, 1.51f, 1.64f, 1.71f, 1.60f, 1.58f, 1.77f, 1.74f, 1.91f, 1.94f, 1.87f, 1.97f, 1.85f, 1.10f, 0.97f, 1.22f, 0.88f, 0.92f, 0.95f, 1.01f, 1.11f, 1.39f, 1.32f, 0.88f, 0.90f, 0.97f, 0.96f, 0.93f, 1.05f, 0.99f, 1.27f, 1.47f, 1.20f, 1.70f, 1.54f, 1.76f, 1.08f, 1.31f, 1.33f, 1.70f, 1.76f, 1.55f, 1.57f, 1.88f, 1.85f, 1.91f, 1.97f, 1.99f, 1.99f, 1.70f, 1.65f, 1.85f, 1.41f, 1.54f, 1.61f, 1.76f, 1.80f, 1.91f, 1.93f, 1.52f, 1.26f, 1.48f, 0.92f, 0.99f, 0.97f, 1.18f, 1.09f, 1.28f, 1.39f, 0.94f, 0.93f, 1.05f, 0.92f, 1.01f, 1.31f, 0.88f, 0.81f, 0.86f, 0.72f, 0.75f, 0.74f, 0.79f, 0.79f, 0.86f, 0.85f, 0.71f, 0.73f, 0.75f, 0.82f, 0.77f, 0.83f, 0.78f, 0.85f, 0.88f, 0.81f, 0.88f, 0.97f, 0.90f, 1.18f, 1.00f, 0.93f, 0.86f, 0.92f, 0.94f, 1.14f, 0.99f, 1.24f, 1.03f, 1.33f, 1.39f, 1.11f, 0.79f, 0.77f, 0.84f, 0.79f, 0.77f, 0.84f, 0.83f, 0.90f, 0.98f, 0.91f, 0.85f, 0.92f, 0.91f, 1.02f, 1.26f, 1.00f, 1.23f, 1.19f, 0.99f, 1.50f, 1.84f, 1.71f, 1.64f, 1.38f, 1.46f, 1.51f, 1.76f, 1.59f, 0.84f, 0.88f, 0.80f, 0.94f, 0.79f, 0.86f, 0.82f, 0.77f, 0.76f, 0.74f, 0.74f, 0.71f, 0.73f, 0.70f, 0.72f, 0.82f, 0.77f, 0.85f, 0.74f, 0.70f, 0.73f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f, 1.00f }
};


/// <summary>
/// Constructor for the Md2 Model
/// </summary>
ModelMd2::ModelMd2()
{
	// Setup our starting animation parameters
	myAnimationFormat = ANIMATION_TRADITIONAL_MD2;
	myAnim.lastTime = 0.0f;
	myAnim.currentTime = 1.0f;
	myAnim.frameLoopCount = 0;
	myAnim.frameIncrement = 0.0f;
	setAnimationType(STAND);
	// Set our model to render at the default location
	myLocation.x = 5.0f; 
	myLocation.y = 5.0f; 
	myLocation.z = 21.1f;	
	myScale = 1.0f;
	myTextureHandle = UNDEFINED_TEXTURE_HANDLE;	
	myBumpTextureHandle = UNDEFINED_TEXTURE_HANDLE;
	myLightmapTextureHandle = UNDEFINED_TEXTURE_HANDLE;
	myVertexArraysConstructed = false;
}
      
/// <summary>
/// Destructor for the Md2 Model
/// </summary>
ModelMd2::~ModelMd2()
{
	myTriangles.clear();
	
	myTexCoords.clear();
	
	myFrames.clear();

	myInterpolatedFrame.clear();

	myScaledMd2Frames.clear();		

	myGLCommands.clear();

	ASSERT(myVertexArraysConstructed == false);	
}

/// <summary>
/// Private procedure for opening the file handle specified ...
/// </summary>
/// <returns>true if successful, else false </returns>
bool ModelMd2::openMyFileHandle(const char *fileName)
{
	//debugPrint("Loading md2 file into memory\n");usleep(1000000);
	// Open the file.
	myFileHandle = fopen(fileName, "rb");
	if (myFileHandle != NULL)
	{
		return true;
	}
	return false;
}


/// <summary>
/// Private procedure to load md2 header data from a file and/or swap the endian-ness
/// </summary>
/// <returns> <c>true</c> [success] else, <c>false</c></returns>
bool ModelMd2::loadMd2HeaderDataFromFile()
{
	bool returnValue = false;
	ASSERT(myFileHandle != NULL);
	// read header file
	u32 bytesRead = fread((char*)&myMd2HeaderData, 1, sizeof(md2HeaderData), myFileHandle);

	if(bytesRead == sizeof(md2HeaderData))
	{
		// Now swap all the endian-shite if we need to *sigh* why haven't we got a standard chip? ftw.

		#ifdef THIS_IS_A_BIG_ENDIAN_SYSTEM	
		SWAP_ENDIAN_LONG(myMd2HeaderData.magicNumber)              	
		SWAP_ENDIAN_LONG(myMd2HeaderData.md2Version)            
		SWAP_ENDIAN_LONG(myMd2HeaderData.skinwidth)          
		SWAP_ENDIAN_LONG(myMd2HeaderData.skinheight)         
		SWAP_ENDIAN_LONG(myMd2HeaderData.framesize)          
		SWAP_ENDIAN_LONG(myMd2HeaderData.numSkins)          
		SWAP_ENDIAN_LONG(myMd2HeaderData.numVertices)            
		SWAP_ENDIAN_LONG(myMd2HeaderData.numTexCoords)             
		SWAP_ENDIAN_LONG(myMd2HeaderData.numTriangles)           
		SWAP_ENDIAN_LONG(myMd2HeaderData.numGlCommands)         
		SWAP_ENDIAN_LONG(myMd2HeaderData.numFrames)         
		SWAP_ENDIAN_LONG(myMd2HeaderData.skinOffset)          
		SWAP_ENDIAN_LONG(myMd2HeaderData.texCoordsDataOffset)             
		SWAP_ENDIAN_LONG(myMd2HeaderData.triangleDataOffset)           
		SWAP_ENDIAN_LONG(myMd2HeaderData.frameDataOffset)         
		SWAP_ENDIAN_LONG(myMd2HeaderData.glCommandDataOffset)         
		SWAP_ENDIAN_LONG(myMd2HeaderData.EOFoffset)
		#endif
				
		//debugPrint("Checking Magic Number: 0x%x, Version: 0x%x\n", myMd2HeaderData.magicNumber, myMd2HeaderData.md2Version);usleep(1000000);
		if((myMd2HeaderData.magicNumber == MD2_MAGIC) && (myMd2HeaderData.md2Version == MD2_VERSION))
		{
			returnValue = true;
		}
	}
	
	return returnValue;
}

/// <summary>
/// Private procedure to load md2 triangle data from a file 
/// </summary>		
/// <returns>[Successfully loaded] true, else false</returns>
bool ModelMd2::loadMd2TriangleDataFromFile()
{
	bool returnValue = false;	
	
	//debugPrint("Loading triangles into memory\n");usleep(1000000);
	
	ASSERT(myFileHandle != NULL);
	
	// Go to the position where the triangle data starts in the file
	fseek(myFileHandle, myMd2HeaderData.triangleDataOffset, SEEK_SET);	
	
	// Read out all of the subsequent triangle objects and load them into our list
	for(u32 triangleIndex = 0; triangleIndex < myMd2HeaderData.numTriangles; triangleIndex++)
	{
		md2Triangle newTriangle;
		u32 trianglesRead = fread(&newTriangle, 1, sizeof(md2Triangle), myFileHandle);	
		if(trianglesRead == sizeof(md2Triangle))
		{			
			// Make sure we do any swapping if this is a big endian system ...
			#ifdef THIS_IS_A_BIG_ENDIAN_SYSTEM		
				SWAP_ENDIAN_SHORT(newTriangle.vertex[0])				
				SWAP_ENDIAN_SHORT(newTriangle.vertex[1])
				SWAP_ENDIAN_SHORT(newTriangle.vertex[2])
				SWAP_ENDIAN_SHORT(newTriangle.st[0])
				SWAP_ENDIAN_SHORT(newTriangle.st[1])
				SWAP_ENDIAN_SHORT(newTriangle.st[2])
			#endif
			//debugPrint("Reading Triangle: %d of %d\n", triangleIndex, myMd2HeaderData.numTriangles);		
			myTriangles.push_back(newTriangle);
			returnValue = true;
		}
	}	
		
	return returnValue;
}

/// <summary>
/// Private procedure to load md2 texture coordinate data from a file 
/// </summary>		
/// <returns>[Successfully loaded] true, else false</returns>
bool ModelMd2::loadMd2TextureCoordinatesFromFile()
{
	bool returnValue = false;	
	
	//debugPrint("Loading texure coords into memory\n");usleep(1000000);
	
	ASSERT(myFileHandle != NULL);
	
	// Go to the position where the triangle data starts in the file
	fseek(myFileHandle, myMd2HeaderData.texCoordsDataOffset, SEEK_SET);	
	
	// Read out all of the subsequent triangle objects and load them into our list
	for(u32 coordIndex = 0; coordIndex < myMd2HeaderData.numTexCoords; coordIndex++)
	{
		md2TexCoord newTexCoord;
		
		u32 coordsRead = fread(&newTexCoord, 1, sizeof(md2TexCoord), myFileHandle);	
		if(coordsRead  == sizeof(md2TexCoord))
		{			
			// Make sure we do any swapping if this is a big endian system ...
			#ifdef THIS_IS_A_BIG_ENDIAN_SYSTEM		
				SWAP_ENDIAN_SHORT(newTexCoord.s)				
				SWAP_ENDIAN_SHORT(newTexCoord.t)				
			#endif
			//debugPrint("Reading Triangle: %d of %d\n", triangleIndex, myMd2HeaderData.numTriangles);		
			myTexCoords.push_back(newTexCoord);
			returnValue = true;
		}
	}	
		
	return returnValue;
}

/// <summary>
/// Used to load md2 gl commands from a file to help accelerate the rendering process...
/// </summary>
bool ModelMd2::loadMd2CommandsFromFile()
{
	bool returnValue = false;	

	//debugPrint("Loading gl command data into memory...\n");usleep(1000000);
	
	ASSERT(myFileHandle != NULL);
	
	// Go to the position where the command data starts in the file
	fseek(myFileHandle, myMd2HeaderData.glCommandDataOffset, SEEK_SET);
	
		// Read out all of the subsequent triangle objects and load them into our list
	for (u32 commandIndex = 0; commandIndex < (myMd2HeaderData.numGlCommands - 1); commandIndex++)
	{
		u32 commandElement;
		u32 sizeRead = fread(&commandElement, 1, sizeof(u32), myFileHandle);
		if (sizeRead == sizeof(32))
		{
			#ifdef THIS_IS_A_BIG_ENDIAN_SYSTEM
				SWAP_ENDIAN_LONG(commandElement);
			#endif
			myGLCommands.push_back((int) commandElement);
			returnValue = true;
		}
	}
		
	return returnValue;
}

/// <summary>
/// Private procedure to load md2 frame data from a file 
/// </summary>
/// <parameter="Buffer> Represents a memory buffer to allocate and store the file info in... Remember to delete!</parameter>
/// <returns>[Successfully loaded] true, else false</returns>
bool ModelMd2::loadMd2FrameDataFromFile()
{
	bool returnValue = false;	
	
	ASSERT(myFileHandle != NULL);
	//debugPrint("Loading frames into memory\n");usleep(1000000);
	
	// Go to the position where the frame data starts in the file
	fseek(myFileHandle, myMd2HeaderData.frameDataOffset, SEEK_SET);	
	// Read out all of the subsequent frames
	for(u32 frameIndex = 0; frameIndex < myMd2HeaderData.numFrames; frameIndex++)
	{
		md2Frame newFrame;
		
		// Read out our scale information
		u32 scalesRead = fread(newFrame.scale, 1, (sizeof(float) * NUMBER_OF_SCALES_IN_FRAME), myFileHandle);	
		ASSERT(scalesRead == (sizeof(float) * NUMBER_OF_SCALES_IN_FRAME));
		if(scalesRead == (sizeof(float) * NUMBER_OF_SCALES_IN_FRAME))
		{
			//debugPrint("	Scale of new frame: %d\n", newFrame->scale[0]);usleep(1000000);
			u32 translatesRead = fread(newFrame.translate, 1, (sizeof(float) * NUMBER_OF_TRANSLATES_IN_FRAME), myFileHandle);	
			ASSERT(translatesRead == (sizeof(float) * NUMBER_OF_TRANSLATES_IN_FRAME));
			if(translatesRead == (sizeof(float) * NUMBER_OF_TRANSLATES_IN_FRAME))
			{
				u32 charsRead = fread(newFrame.name, 1, (sizeof(char) * NUMBER_OF_CHARS_IN_FRAME), myFileHandle);	
				ASSERT(charsRead == (sizeof(char) * NUMBER_OF_CHARS_IN_FRAME));
				if(charsRead == (sizeof(char) * NUMBER_OF_CHARS_IN_FRAME))
				{
					// Now read each vertex into our list...
					for(u32 vertIndex = 0; vertIndex < myMd2HeaderData.numVertices; vertIndex++)
					{
						md2Vertex newVertex;
						u32 vertsRead = fread(&newVertex, sizeof(md2Vertex), 1, myFileHandle);	
						ASSERT(vertsRead == 1);
						if(vertsRead == 1)
						{							
							newFrame.verts.push_back(newVertex);
						}
						
					}// end for vertIndex	
					
					#ifdef THIS_IS_A_BIG_ENDIAN_SYSTEM		
						SWAP_ENDIAN_FLOAT(newFrame.scale[0]);
						SWAP_ENDIAN_FLOAT(newFrame.scale[1]);
						SWAP_ENDIAN_FLOAT(newFrame.scale[2]);
						SWAP_ENDIAN_FLOAT(newFrame.translate[0]);
						SWAP_ENDIAN_FLOAT(newFrame.translate[1]);
						SWAP_ENDIAN_FLOAT(newFrame.translate[2]); 							
					#endif
					// WE @#$%ing did it!!! Hell yes, push this sucker on the list!!!
					//debugPrint("Reading Frame: %d of %d\n", frameIndex, myMd2HeaderData.numFrames);
					myFrames.push_back(newFrame);
					returnValue = true;	
				}// end if charsRead
			}// end if translatesRead
		}// end if scalesRead
	}	

	return returnValue;
}

	  
/// <summary>
/// Will load the necessary md2 data from a file ...
/// </summary>
bool ModelMd2::loadFromFile(const char *fileName, AnimationFormat animationFormat)
{	
	bool returnValue = false;
			
	if (openMyFileHandle(fileName) == true)
	{		
		// If we read the header out properly ...
		if(loadMd2HeaderDataFromFile() == true)
		{			
			// Load our triangles
			if(loadMd2TriangleDataFromFile() == true)
			{
				// Read out the frame data by reference ...
				if(loadMd2FrameDataFromFile() == true)
				{										
					if(loadMd2TextureCoordinatesFromFile() == true)
					{
						//if(loadMd2CommandsFromFile() == true)
						//{

							// Md2 models can't use the animation texture format...
							ASSERT(animationFormat != ANIMATION_TEXTURE);

							myAnimationFormat = animationFormat;

							returnValue = true;				
							//debugPrint("Md2 file has been loaded into memory! Yehaw!\n");usleep(1000000);			
						//}
					}
				}				
			}
			
		} // end if (bytesRead
	}// end if(myFileHandle	

	// close the file and return
	fclose(myFileHandle);	

	return returnValue;
}
	  
/// <summary>
/// Will translate model to vector coordinates
/// </summary>
void ModelMd2::translateModel(Vector translation)
{
	myLocation = translation;
}

/// <summary>
/// Performs all the necessary calculations to create a scaled frame that can be used for rendering...
/// </summary>
void ModelMd2::buildScaledFrame(ScaledFrame &triangles, bool interpolate)
{		
	//ASSERT(graphics != NULL);
	ASSERT(myAnim.currFrame >= 0);
	ASSERT(myAnim.currFrame < myMd2HeaderData.numFrames);
	
	// Loop through the number of traingles used in this model ...
	for(u32 triangleIndex = 0; triangleIndex < myMd2HeaderData.numTriangles; triangleIndex++)
	{
		Triangle newTriangle;
		if(interpolate == true)
		{
			newTriangle = getInterpolatedTriangle(triangleIndex);
		}
		else
		{
			newTriangle = getCurrentScaledTriangle(triangleIndex);			
		}
		//debugPrint("Triangle %d: Vertex: %d, %f, %f, %f\n", triangleIndex, vertexIndex, newTriangle.verticies[vertexIndex].x, newTriangle.verticies[vertexIndex].y, newTriangle.verticies[vertexIndex].z);						
		triangles.push_back(newTriangle);
	}	
}

/// <summary>
/// Builds a new frame that is interpolated between two other frames based on time
/// </summary>
void ModelMd2::buildInterpolatedFrame(TriangleVertexArray &currentFrame, TriangleVertexArray &nextFrame, TriangleVertexArray &interpolatedFrame)
{
	// Loop through the number of traingles used in this model ...
	for(u32 triangleIndex = 0; triangleIndex < (myMd2HeaderData.numTriangles * 3); triangleIndex+=3)
	{
		// To interpolate each triangle we:
		// 1. subtract the verticies from the next frame from the current frame and store the difference in the verticies for the interpolate frame		
		// 2. Multiply the value stored in interpolated frame by the interpolation value
		// 3. Add current frame to the value in interpolated frame, and voila! We've got an interpolated triangle

		fastVectorSubtract(&nextFrame.Verticies[triangleIndex + 0], &currentFrame.Verticies[triangleIndex + 0], &interpolatedFrame.Verticies[triangleIndex + 0]);
		fastVectorSubtract(&nextFrame.Verticies[triangleIndex + 1], &currentFrame.Verticies[triangleIndex + 1], &interpolatedFrame.Verticies[triangleIndex + 1]);
		fastVectorSubtract(&nextFrame.Verticies[triangleIndex + 2], &currentFrame.Verticies[triangleIndex + 2], &interpolatedFrame.Verticies[triangleIndex + 2]);
				
		fastVectorScale(&interpolatedFrame.Verticies[triangleIndex + 0], &interpolatedFrame.Verticies[triangleIndex + 0], myAnim.interpolateBy);
		fastVectorScale(&interpolatedFrame.Verticies[triangleIndex + 1], &interpolatedFrame.Verticies[triangleIndex + 1], myAnim.interpolateBy);
		fastVectorScale(&interpolatedFrame.Verticies[triangleIndex + 2], &interpolatedFrame.Verticies[triangleIndex + 2], myAnim.interpolateBy);

		fastVectorAdd(&interpolatedFrame.Verticies[triangleIndex + 0], &currentFrame.Verticies[triangleIndex + 0], &interpolatedFrame.Verticies[triangleIndex + 0]);				
		fastVectorAdd(&interpolatedFrame.Verticies[triangleIndex + 1], &currentFrame.Verticies[triangleIndex + 1], &interpolatedFrame.Verticies[triangleIndex + 1]);				
		fastVectorAdd(&interpolatedFrame.Verticies[triangleIndex + 2], &currentFrame.Verticies[triangleIndex + 2], &interpolatedFrame.Verticies[triangleIndex + 2]);						
	}

#ifdef PLATFORM_IS_WII	
	DCFlushRange(interpolatedFrame.Verticies, (interpolatedFrame.VertexStride * interpolatedFrame.VertexArraySize * 3));
#endif
}

/// <summary>
/// Can be called after begin scene has been called, it will render the model in the scene, using it's own inernal animation state...
/// </summary>
void ModelMd2::renderModel(IGraphics *graphics, bool interpolate)
{	
	renderModel(graphics, myAnim, interpolate);
}

/// <summary>
/// Handles the interpolation and rendering of an md2 model
/// </summary>
static void handleRenderingProcess(IGraphics *graphics, Vector &location, TextureHandle &textureHandle,
								   TextureHandle &lightHandle, TextureHandle &bumpHandle, TriangleVertexArray &arrayToRender)
{
	if(bumpHandle == UNDEFINED_TEXTURE_HANDLE)
	{
		graphics->addVertexArrayToScene(location, textureHandle, arrayToRender);
	}
	else
	{
		graphics->addNormalMappedVertexArrayToScene(BUMP_TYPE_XYZ_MAP, location, textureHandle, lightHandle, bumpHandle, arrayToRender);
	}
}

/// <summary>
/// Can be called after begin scene has been called, it will render the model in the scene...
/// </summary>
void ModelMd2::renderModel(IGraphics *graphics, ModelAnimState &animation, bool interpolate)
{				
	myAnim = animation;

	if(graphics != NULL)
	{		
		ASSERT(myTextureHandle != UNDEFINED_TEXTURE_HANDLE);
		
		if(myTextureHandle != UNDEFINED_TEXTURE_HANDLE)
		{				
			//printf("\x1b[2;0H"); printf("Model Location: x:%4.4f\n y:%4.4f\n z:%4.4f\n", myLocation.x,  myLocation.y, myLocation.z);

			ASSERT(myVertexArraysConstructed == true);
			if(myVertexArraysConstructed  == true)
			{
				TriangleVertexArray *arrayToRender;
				if(interpolate == false)
				{
					arrayToRender = &myMd2VertexArrays.at(myAnim.currFrame);
				}
				else
				{					
					buildInterpolatedFrame(myMd2VertexArrays.at(myAnim.currFrame), myMd2VertexArrays.at(myAnim.nextFrame), myInterpolatedVertexArray);
					arrayToRender = &myInterpolatedVertexArray;
				}
				// Now determine if we need to use bump mapping or not, and render our model ...
				handleRenderingProcess(graphics, myLocation, myTextureHandle, myLightmapTextureHandle, myBumpTextureHandle, *arrayToRender);
			}			
		}
	}
}

/// <summary>
/// Get Current Triangle used in getInterpolatedTriangle
/// </summary>
inline Triangle ModelMd2::getCurrentTriangle(int triangleIndex)
{
	Triangle currentTriangle;
	
	for(u32 vertexIndex = 0; vertexIndex < 3; vertexIndex++)
	{
		currentTriangle.verticies[vertexIndex].x = ((myFrames.at(myAnim.currFrame).scale[0] 
			* myFrames.at(myAnim.currFrame).verts.at(myTriangles.at(triangleIndex).vertex[vertexIndex]).v[0]) 
			+ myFrames.at(myAnim.currFrame).translate[0]);
			
		currentTriangle.verticies[vertexIndex].y = ((myFrames.at(myAnim.currFrame).scale[1] 
		 	* myFrames.at(myAnim.currFrame).verts.at(myTriangles.at(triangleIndex).vertex[vertexIndex]).v[1]) 
			+ myFrames.at(myAnim.currFrame).translate[1]);								   
			
		currentTriangle.verticies[vertexIndex].z = ((myFrames.at(myAnim.currFrame).scale[2] 
		 	* myFrames.at(myAnim.currFrame).verts.at(myTriangles.at(triangleIndex).vertex[vertexIndex]).v[2]) 
			+ myFrames.at(myAnim.currFrame).translate[2]);

		// Get our reference into the texture coordinates for this triangle ...		
		float fshortValue = myTexCoords.at(myTriangles.at(triangleIndex).st[vertexIndex]).s;
		float skinSize = (float)myMd2HeaderData.skinwidth;
		currentTriangle.texture_S[vertexIndex] = (fshortValue/ skinSize);
		
		fshortValue = myTexCoords.at(myTriangles.at(triangleIndex).st[vertexIndex]).t;
		skinSize = (float)myMd2HeaderData.skinheight;
		currentTriangle.texture_T[vertexIndex] = (fshortValue/ skinSize);		
		
		//debugPrint("S:%f, T:%f\n", currentTriangle.texture_S[vertexIndex], currentTriangle.texture_T[vertexIndex]);
	}
	
	return currentTriangle;
}

/// <summary>
/// Get Current Triangle used in getInterpolatedTriangle
/// </summary>
inline Triangle ModelMd2::getCurrentScaledTriangle(int triangleIndex)
{
	Triangle currentTriangle;
	
	for(u32 vertexIndex = 0; vertexIndex < 3; vertexIndex++)
	{
		// Get each scaled vertex of the triangle
		currentTriangle.verticies[vertexIndex].x = ((myFrames.at(myAnim.currFrame).scale[0] 
			* myFrames.at(myAnim.currFrame).verts.at(myTriangles.at(triangleIndex).vertex[vertexIndex]).v[0]) 
			+ myFrames.at(myAnim.currFrame).translate[0]) * myScale;
			
		currentTriangle.verticies[vertexIndex].y = ((myFrames.at(myAnim.currFrame).scale[1] 
		 	* myFrames.at(myAnim.currFrame).verts.at(myTriangles.at(triangleIndex).vertex[vertexIndex]).v[1]) 
			+ myFrames.at(myAnim.currFrame).translate[1]) * myScale;								   
			
		currentTriangle.verticies[vertexIndex].z = ((myFrames.at(myAnim.currFrame).scale[2] 
		 	* myFrames.at(myAnim.currFrame).verts.at(myTriangles.at(triangleIndex).vertex[vertexIndex]).v[2]) 
			+ myFrames.at(myAnim.currFrame).translate[2]) * myScale;

		// Get our reference into the texture coordinates for this triangle ...		
		float fshortValue = myTexCoords.at(myTriangles.at(triangleIndex).st[vertexIndex]).s;
		float skinSize = (float)myMd2HeaderData.skinwidth;
		currentTriangle.texture_S[vertexIndex] = (fshortValue/ skinSize);
		
		fshortValue = myTexCoords.at(myTriangles.at(triangleIndex).st[vertexIndex]).t;
		skinSize = (float)myMd2HeaderData.skinheight;
		currentTriangle.texture_T[vertexIndex] = (fshortValue/ skinSize);		
		//debugPrint("S:%f, T:%f\n", currentTriangle.texture_S[vertexIndex], currentTriangle.texture_T[vertexIndex]);
	}
	// Get the normal for each vertex...		
	currentTriangle.normals[0] = myPreCalculatedNormals[myFrames.at(myAnim.currFrame).verts.at(myTriangles.at(triangleIndex).vertex[2]).lightnormalindex];
	currentTriangle.normals[1] = myPreCalculatedNormals[myFrames.at(myAnim.currFrame).verts.at(myTriangles.at(triangleIndex).vertex[1]).lightnormalindex];
	currentTriangle.normals[2] = myPreCalculatedNormals[myFrames.at(myAnim.currFrame).verts.at(myTriangles.at(triangleIndex).vertex[0]).lightnormalindex];
	
	return currentTriangle;
}

		
/// <summary>
/// Get the Next Triangle used in getInterpolatedTraingle
/// </summary>
inline Triangle ModelMd2::getNextTriangle(int triangleIndex)
{	
	Triangle nextTriangle;
	
	for(u32 vertexIndex = 0; vertexIndex < 3; vertexIndex++)
	{
		nextTriangle.verticies[vertexIndex].x = ((myFrames.at(myAnim.nextFrame).scale[0] 
			* myFrames.at(myAnim.nextFrame).verts.at(myTriangles.at(triangleIndex).vertex[vertexIndex]).v[0]) 
			+ myFrames.at(myAnim.nextFrame).translate[0]);
			
		nextTriangle.verticies[vertexIndex].y = ((myFrames.at(myAnim.nextFrame).scale[1] 
		 	* myFrames.at(myAnim.nextFrame).verts.at(myTriangles.at(triangleIndex).vertex[vertexIndex]).v[1]) 
			+ myFrames.at(myAnim.nextFrame).translate[1]);								   
			
		nextTriangle.verticies[vertexIndex].z = ((myFrames.at(myAnim.nextFrame).scale[2] 
		 	* myFrames.at(myAnim.nextFrame).verts.at(myTriangles.at(triangleIndex).vertex[vertexIndex]).v[2]) 
			+ myFrames.at(myAnim.nextFrame).translate[2]);		
	}
	
	return nextTriangle;
}
	
/// <summary>
/// Get an interpolated Triangle using getCurrentTriangle and getNextTriangle
/// </summary>		
inline Triangle ModelMd2::getInterpolatedTriangle(int triangleIndex)
{
	Triangle currentTriangle; 
	Triangle nextTriangle; 
	Triangle interpolatedTriangle;
	
	currentTriangle = getCurrentTriangle(triangleIndex);
	nextTriangle = getNextTriangle(triangleIndex);
	// Interpolate all of our indices
	for(u32 vertexIndex = 0; vertexIndex < 3; vertexIndex++)
	{	
		// To get the interpolated triangle we subtract next from current, multiply that (or scale) by the interpolation value
		// This gets stored in interpolatedTriangle, and then we add currentTriangle to that to get our full interpolated triangle.
		fastVectorSubtract(&nextTriangle.verticies[vertexIndex], &currentTriangle.verticies[vertexIndex], &interpolatedTriangle.verticies[vertexIndex]);
		fastVectorScale(&interpolatedTriangle.verticies[vertexIndex], &interpolatedTriangle.verticies[vertexIndex], myAnim.interpolateBy);
		fastVectorAdd(&interpolatedTriangle.verticies[vertexIndex], &currentTriangle.verticies[vertexIndex], &interpolatedTriangle.verticies[vertexIndex]);		

		// Now that we have an interpolated triangle let's scale it...
		fastVectorScale(&interpolatedTriangle.verticies[vertexIndex], &interpolatedTriangle.verticies[vertexIndex], myScale);
		
		interpolatedTriangle.texture_S[vertexIndex] = currentTriangle.texture_S[vertexIndex];
		interpolatedTriangle.texture_T[vertexIndex] = currentTriangle.texture_T[vertexIndex];

		// Get the normal for each triangle ...
		//currentTriangle.normals[vertexIndex] = myPreCalculatedNormals[myFrames.at(myAnim.currFrame).verts.at(myTriangles.at(triangleIndex).vertex[vertexIndex]).lightnormalindex];
		//debugPrint("Vertex %d TexCoordinates: %f, %f\n", vertexIndex, interpolatedTriangle.texture_S[vertexIndex], interpolatedTriangle.texture_T[vertexIndex]);
	}
	// Get the normal for each vertex...		
	interpolatedTriangle.normals[0] = myPreCalculatedNormals[myFrames.at(myAnim.currFrame).verts.at(myTriangles.at(triangleIndex).vertex[2]).lightnormalindex];
	interpolatedTriangle.normals[1] = myPreCalculatedNormals[myFrames.at(myAnim.currFrame).verts.at(myTriangles.at(triangleIndex).vertex[1]).lightnormalindex];
	interpolatedTriangle.normals[2] = myPreCalculatedNormals[myFrames.at(myAnim.currFrame).verts.at(myTriangles.at(triangleIndex).vertex[0]).lightnormalindex];
	
	// If we have a texture loaded, then let's pass the handle over to the triangle object
	
	return interpolatedTriangle;
}

/// <summary>
/// Some models r big, some models r small, this helps determine which one that is ...
/// </summary>				
void ModelMd2::setModelScale( float scale )
{
	ASSERT(myVertexArraysConstructed == false);
	if(myVertexArraysConstructed == false)
	{
		myScale = scale;
		// Now we want to go through and build all of our scaled frames						
		myScaledMd2Frames.clear();
		myInterpolatedFrame.clear();	
		for(myAnim.currFrame = 0; myAnim.currFrame < myMd2HeaderData.numFrames; myAnim.currFrame++)
		{	
			ScaledFrame newFrame;
			buildScaledFrame(newFrame, false);
			myScaledMd2Frames.push_back(newFrame);
		}
		// This builds our interpolated frame object so that it doesn't need to allocate memory as it is modified...
		myAnim.currFrame = 0;
		buildScaledFrame(myInterpolatedFrame, false);	
	}
}

/// <summary>
/// Cleans up our vertex arrays...
/// </summary>				
void ModelMd2::freeVertexArrays(IGraphics *graphics)
{
	VertexFrame::iterator vertexArrayIterator;
	vertexArrayIterator = myMd2VertexArrays.begin();
	// Free all of the vertex arrays in the md2 vertex array vector
	for(u32 idx = 0; idx < myMd2VertexArrays.size(); idx++)
	{
		graphics->freeVertexArray(*vertexArrayIterator);
		vertexArrayIterator++;
	}
	// free our interpolated frame...
	graphics->freeVertexArray(myInterpolatedVertexArray);
	myVertexArraysConstructed = false;
}

/// <summary>
/// Will build vertex arrays from our Scaled frames for faster rendering ...
/// IMPORTANT: Once vertex arrays are built, all other model memory is discarded!
/// </summary>				
void ModelMd2::buildVertexArrays(IGraphics *graphics, bool cullBacks)
{
	ASSERT(myVertexArraysConstructed == false);
	bool normalDataAllocated = false;
	fixedVector *preAllocatedNormalData = NULL;
	if(myVertexArraysConstructed == false)
	{		
		for(u32 idx = 0; idx < myMd2HeaderData.numFrames; idx++)
		{
			TriangleVertexArray newTriangleArray;
			
			// To save memory, we're only going to use one set of normals (that's the diff between 4.5k of normals per model and 800k!)
			if(normalDataAllocated == false)
			{
				// If Normals is NULL IGraphics implementation will allocate it...
				newTriangleArray.Normals = NULL;								
			}
			else
			{
				newTriangleArray.Normals = preAllocatedNormalData;				
			}
			
			graphics->allocateAndPopulateVertexArray(myScaledMd2Frames.at(idx), newTriangleArray, cullBacks);
			
			if(normalDataAllocated == false)
			{				
				preAllocatedNormalData = newTriangleArray.Normals;
				normalDataAllocated = true;
			}

			myMd2VertexArrays.push_back(newTriangleArray);
		}
		
		// Generate the frame we'll use for rendering interpolated data...
		myInterpolatedVertexArray.Normals = NULL;
		graphics->allocateAndPopulateVertexArray(myInterpolatedFrame, myInterpolatedVertexArray, cullBacks);

		// Clear out all of the old md2 data since we have our vertex arrays. 
		myInterpolatedFrame.clear();
		myTriangles.clear();
		myTexCoords.clear();
		myFrames.clear();
		myInterpolatedFrame.clear();
		myScaledMd2Frames.clear();	
		
		// Make sure we mark our arrays as constructed, we don't allow changes once this is done ...
		myVertexArraysConstructed = true;
	}
}

/// <summary>
/// Handles all the logic necessary for animating this model ...
/// </summary>
void ModelMd2::handleAnimation(float time, ModelAnimState &modelAnim)
{
	modelAnim.currentTime += time;

	float timeDifference = (modelAnim.currentTime - modelAnim.lastTime);
	float animFPS = (1.0f / modelAnim.fps);
	modelAnim.frameIncrement += (timeDifference);

	if ((myAnimationFormat == ANIMATION_PRE_RENDERED_MD2) || (myAnimationFormat == ANIMATION_BADDIE_MD2))
	{
		// If enough time has passed to render a single frame...
		if ((modelAnim.frameIncrement > animFPS) || (modelAnim.lastTime == 0.0f))
		{
			modelAnim.frameIncrement -= animFPS;

			modelAnim.currFrame = modelAnim.nextFrame;

			//while (modelAnim.frameIncrement >= animFPS)
			//{
				// Reduce the frame increment by one frame, and change our frame number
				// either backward or forward based on the animation start and end frames
				modelAnim.frameIncrement -= animFPS;

				// Ok, this is how this works. The max # of frames we can skip for an animation
				// is the fps for that animation / 60. For instance:
				// [fps == 60] maxFrameSkip = 1;
				// [fps == 30] maxFrameSkip = 0; (30 FPS in theory is the lowest we will go due to vsync)
				// [fps == 480] maxFrameSkip = 8;
				int maxFrameSkip = (modelAnim.fps / 60);
				modelAnim.frameSkip = (char)(modelAnim.frameIncrement / animFPS);
				if(modelAnim.frameSkip > maxFrameSkip) modelAnim.frameSkip = maxFrameSkip;

				if (modelAnim.startFrame <= modelAnim.endFrame)
				{
					modelAnim.nextFrame += (1 + modelAnim.frameSkip);
					if (modelAnim.nextFrame > modelAnim.endFrame)
					{
						modelAnim.currFrame = modelAnim.endFrame;
						modelAnim.nextFrame = modelAnim.startFrame;
						modelAnim.frameLoopCount++;
						modelAnim.frameIncrement = 0.0f;
					}
				}
				else
				{
					modelAnim.nextFrame -= (1 + modelAnim.frameSkip);
					if (modelAnim.nextFrame <= modelAnim.endFrame)
					{
						modelAnim.currFrame = modelAnim.endFrame;
						modelAnim.nextFrame = modelAnim.startFrame;
						modelAnim.frameLoopCount++;
						modelAnim.frameIncrement = 0.0f;
					}
				}
			//} // end while
		}
		modelAnim.lastTime = modelAnim.currentTime;
	}
	else //if (myAnimationFormat == ANIMATION_TRADITIONAL_MD2), or STATIC
	{
		if ((timeDifference > animFPS) || (modelAnim.lastTime == 0.0f))
		{
			modelAnim.currFrame = modelAnim.nextFrame;

			if (modelAnim.startFrame <= modelAnim.endFrame)
			{
				modelAnim.nextFrame++;
				if (modelAnim.nextFrame > modelAnim.endFrame)
				{
					modelAnim.currFrame = modelAnim.endFrame;
					modelAnim.nextFrame = modelAnim.startFrame;
				}
			}
			else
			{
				modelAnim.nextFrame--;
				if (modelAnim.nextFrame <= modelAnim.endFrame)
				{
					modelAnim.currFrame = modelAnim.endFrame;
					modelAnim.nextFrame = modelAnim.startFrame;
				}
			}

			modelAnim.lastTime = modelAnim.currentTime;
		}
	}

	// Prevent ouverrunning our total frames
	if (modelAnim.currFrame > (myMd2HeaderData.numFrames - 1))
	{
		modelAnim.currFrame = 0;
	}

	if (modelAnim.nextFrame > (myMd2HeaderData.numFrames - 1))
	{
		modelAnim.nextFrame = 0;
	}

	// Round off our interpolation value to the nearest 10th...
	modelAnim.interpolateBy = modelAnim.fps * (modelAnim.currentTime - modelAnim.lastTime);
	//modelAnim.interpolateBy = float(int(modelAnim.interpolateBy * 10 + 0.5)) / 10;
	// Create a key value we can use to index that interpolated frame ...
	//modelAnim.frameKey = (float) (modelAnim.currFrame + modelAnim.interpolateBy);
}

// initialize the 21 MD2 model animations.
md2Animation ModelMd2::myTraditionalAnimations[ TOTAL_MD2_ANIMATIONS ] =
{
	// first, last, fps
	{   0,  39, 20 },	// STAND
	{  40,  45, 20 },	// RUN
	{  46,  53, 36 },	// ATTACK_A
	{  46,  53, 36 },	// ATTACK_B
	{  46,  53, 36 },	// ATTACK_C
	{  54,  57,  5},	// PAIN_A
	{  58,  61,  5},	// PAIN_B
	{  62,  65,  5},	// PAIN_C
	{  66,  71,  10 },	// JUMP
	{  72,  83,  15 },	// FLIP
	{  84,  94,  15 },	// SALUTE
	{  95, 111, 10 },	// FALLBACK
	{ 112, 122,  10 },	// WAVE
	{ 123, 134,  10 },	// POINT
	{ 135, 153, 10 },	// CROUCH_STAND
	{ 154, 159,  7 },	// CROUCH_WALK
	{ 160, 168, 65 },	// CROUCH_ATTACK
	{ 169, 172,  7 },	// CROUCH_PAIN
	{ 173, 177,  5 },	// CROUCH_DEATH
	{ 178, 183,  5 },	// DEATH_FALLBACK
	{ 184, 189,  7 },	// DEATH_FALLFORWARD
	{ 190, 197,  5 },	// DEATH_FALLBACKSLOW
	{ 198, 198,  5 },	// BOOM
	{  53,  46, 40 },	// REVERSE_ATTACK
};

// initialize the 21 MD2 model animations.
md2Animation ModelMd2::myFullAnimations[ TOTAL_MD2_ANIMATIONS ] =
{
	// first, last, fps
	{   0,  39,  50},	// STAND
	{  40,  60,  110},	// RUN
	{  61,  88,  130},	// ATTACK_A
	{  61,  88,  130},	// ATTACK_B
	{  61,  88,  130},	// ATTACK_C
	{  89, 102,  60},	// PAIN_A
	{ 103, 116,  60},	// PAIN_B
	{ 117, 130,  60},	// PAIN_C
	{ 131, 151,  100},	// JUMP
	{ 152, 193,  80},	// FLIP
	{ 194, 232,  80},	// SALUTE
	{ 233, 291,  60},	// FALLBACK
	{ 292, 329,  100},	// WAVE
	{ 330, 373,  60},	// POINT
	{ 330, 373,  60},	// CROUCH_STAND
	{ 330, 373,  60},	// CROUCH_WALK
	{ 374, 405,  360},	// CROUCH_ATTACK
	{ 374, 405,  60},	// CROUCH_PAIN
	{ 374, 405,  60},	// CROUCH_DEATH
	{ 406, 436,  60},	// DEATH_FALLBACK
	{ 437, 457,  60},	// DEATH_FALLFORWARD
	{ 458, 504,  60},	// DEATH_FALLBACKSLOW
	{ 458, 504,  60},	// BOOM
	{  88,  61,  140}	// REVERSE_ATTACK
};

// initialize the 21 MD2 model animations.
md2Animation ModelMd2::myTraditionalFastAnimations[ TOTAL_MD2_ANIMATIONS ] =
{
	// first, last, fps

	{   0,  39,  36 },	// STAND
	{  40,  45, 10 },	// RUN
	{  46,  53, 40 },	// ATTACK_A
	{  46,  53, 40 },	// ATTACK_B
	{  46,  53, 40 },	// ATTACK_C
	{  54,  57,  5},	// PAIN_A
	{  58,  61,  5},	// PAIN_B
	{  62,  65,  5},	// PAIN_C
	{  66,  71,  7 },	// JUMP
	{  72,  83,  7 },	// FLIP
	{  84,  94,  7 },	// SALUTE
	{  95, 111, 10 },	// FALLBACK
	{ 112, 122,  7 },	// WAVE
	{ 123, 134,  6 },	// POINT
	{ 135, 153, 10 },	// CROUCH_STAND
	{ 154, 159,  7 },	// CROUCH_WALK
	{ 160, 168, 65 },	// CROUCH_ATTACK
	{ 169, 172,  7 },	// CROUCH_PAIN
	{ 173, 177,  5 },	// CROUCH_DEATH
	{ 178, 183,  5 },	// DEATH_FALLBACK
	{ 184, 189,  7 },	// DEATH_FALLFORWARD
	{ 190, 197,  24 },	// DEATH_FALLBACKSLOW
	{ 198, 198,  5 },	// BOOM
	{  54,  46, 40 },	// REVERSE_ATTACK
};

// initialize the 21 MD2 model animations.
md2Animation ModelMd2::myStaticAnimations[ TOTAL_MD2_ANIMATIONS ] =
{
	// first, last, fps

	{  0,  0,  36 },	// STAND
	{  0,  0,  10 },	// RUN
	{  0,  0,  40 },	// ATTACK_A
	{  0,  0,  40 },	// ATTACK_B
	{  0,  0,  40 },	// ATTACK_C
	{  0,  0,  5  },	// PAIN_A
	{  0,  0,  5  },	// PAIN_B
	{  0,  0,  5  },	// PAIN_C
	{  0,  0,  7  },	// JUMP
	{  0,  0,  7  },	// FLIP
	{  0,  0,  7  },	// SALUTE
	{  0,  0,  10 },	// FALLBACK
	{  0,  0,  7  },	// WAVE
	{  0,  0,  6  },	// POINT
	{  0,  0,  10 },	// CROUCH_STAND
	{  0,  0,  7  },	// CROUCH_WALK
	{  0,  0,  65 },	// CROUCH_ATTACK
	{  0,  0,  7  },	// CROUCH_PAIN
	{  0,  0,  5  },	// CROUCH_DEATH
	{  0,  0,  5  },	// DEATH_FALLBACK
	{  0,  0,  7  },	// DEATH_FALLFORWARD
	{  0,  0,  24 },	// DEATH_FALLBACKSLOW
	{  0,  0,  5  },	// BOOM
	{  0,  0,  40 }		// REVERSE_ATTACK
};


// initialize the 21 MD2 model animations.
md2Animation ModelMd2::myFullBaddieAnims[ TOTAL_MD2_ANIMATIONS ] =
{
	// first, last, fps
		{   0,  39,  50},	// STAND
		{  40,  60,  90},	// RUN
		{  61,  88,  140},	// ATTACK_A
		{  61,  88,  140},	// ATTACK_B
		{  61,  88,  140},	// ATTACK_C
		{  89, 102,  60},	// PAIN_A
		{ 103, 116,  60},	// PAIN_B
		{   0,   0,   0},	// PAIN_C
		{   0,   0,   0},	// JUMP
		{   0,   0,   0},	// FLIP
		{   0,   0,   0},	// SALUTE
		{   0,   0,   0},	// FALLBACK
		{   0,   0,   0},	// WAVE
		{   0,   0,   0},	// POINT
		{   0,   0,   0},	// CROUCH_STAND
		{   0,   0,   0},	// CROUCH_WALK
		{ 131, 161,  180},	// CROUCH_ATTACK
		{   0,   0,   0},	// CROUCH_PAIN
		{   0,   0,   0},	// CROUCH_DEATH
		{ 161, 193,  60},	// DEATH_FALLBACK
		{ 194, 213,  60},	// DEATH_FALLFORWARD
		{ 214, 260,  60},	// DEATH_FALLBACKSLOW
		{   0,   0,   0},	// BOOM
		{  88,  61,  140},	// REVERSE_ATTACK
};

// initialize the 21 MD2 model animations.
md2Animation ModelMd2::myInterpolatedBaddieAnims[ TOTAL_MD2_ANIMATIONS ] =
{
	// first, last, fps
		{  0,  3,  50},	// STAND
		{  4,  7,  90},	// RUN
		{  8,  13, 140},	// ATTACK_A
		{  14, 19, 140},	// ATTACK_B
		{  20, 25, 140},	// ATTACK_C
		{  26, 30, 60},		// PAIN_A
		{  31, 35, 60},		// PAIN_B
		{  36, 40, 60},		// PAIN_C
		{   0,   0,   0},	// JUMP
		{   0,   0,   0},	// FLIP
		{   0,   0,   0},	// SALUTE
		{   0,   0,   0},	// FALLBACK
		{   0,   0,   0},	// WAVE
		{   0,   0,   0},	// POINT
		{   0,   0,   0},	// CROUCH_STAND
		{   0,   0,   0},	// CROUCH_WALK
		{  41,  45,  180},	// CROUCH_ATTACK
		{   0,   0,   0},	// CROUCH_PAIN
		{   0,   0,   0},	// CROUCH_DEATH
		{  46,  54,  60},	// DEATH_FALLBACK
		{  55,  63,  60},	// DEATH_FALLFORWARD
		{  64,  72,  60},	// DEATH_FALLBACKSLOW
		{   0,   0,   0},	// BOOM
		{  13,   8,  140},	// REVERSE_ATTACK
};


/// <summary>
/// Decides what type of animation to render ...
/// </summary>		
void ModelMd2::setAnimationType(AnimationType type)
{
	setAnimationType(type, myAnim);
}

/// <summary>
/// Decides what type of animation to render ...
/// </summary>		
void ModelMd2::setAnimationType(AnimationType type, ModelAnimState &modelAnim)
{
	if( (type < STAND) || (type > MAX_ANIMATIONS) )
	{
		type = STAND;
		myAnim.frameLoopCount = 0;
	}
	
	if(myAnimationFormat == ANIMATION_TRADITIONAL_MD2)
	{
		modelAnim.startFrame	= myTraditionalAnimations[ type ].firstFrame;
		modelAnim.endFrame		= myTraditionalAnimations[ type ].lastFrame;
		modelAnim.nextFrame	= myTraditionalAnimations[ type ].firstFrame + 1;
		modelAnim.fps			= myTraditionalAnimations[ type ].fps;
		modelAnim.type			= type;
		myAnim.frameLoopCount = 0;
	}
	else if (myAnimationFormat == ANIMATION_TRADITIONAL_FAST_MD2)
	{
		modelAnim.startFrame = myTraditionalFastAnimations[type].firstFrame;
		modelAnim.endFrame = myTraditionalFastAnimations[type].lastFrame;
		modelAnim.nextFrame = myTraditionalFastAnimations[type].firstFrame + 1;
		modelAnim.fps = myTraditionalFastAnimations[type].fps;
		modelAnim.type = type;
		myAnim.frameLoopCount = 0;
	}
	else if (myAnimationFormat == ANIMATION_PRE_RENDERED_MD2)
	{
		modelAnim.startFrame	= myFullAnimations[ type ].firstFrame;
		modelAnim.endFrame		= myFullAnimations[ type ].lastFrame;

		if(modelAnim.startFrame <= modelAnim.endFrame) modelAnim.nextFrame = myFullAnimations[ type ].firstFrame + 1;
		else modelAnim.nextFrame = myFullAnimations[ type ].firstFrame - 1;

		modelAnim.fps			= myFullAnimations[ type ].fps;
		modelAnim.type			= type;
		myAnim.frameLoopCount = 0;
	}
	else if (myAnimationFormat == ANIMATION_STATIC_MD2)
	{
		modelAnim.startFrame	= myStaticAnimations[ type ].firstFrame;
		modelAnim.endFrame		= myStaticAnimations[ type ].lastFrame;
		modelAnim.nextFrame		= myStaticAnimations[ type ].firstFrame + 1;
		modelAnim.fps			= myStaticAnimations[ type ].fps;
		modelAnim.type			= type;
		myAnim.frameLoopCount = 0;
	}
	else if (myAnimationFormat == ANIMATION_BADDIE_MD2)
	{
		modelAnim.startFrame = myFullBaddieAnims[type].firstFrame;
		modelAnim.endFrame = myFullBaddieAnims[type].lastFrame;
		modelAnim.nextFrame = myFullBaddieAnims[type].firstFrame + 1;
		modelAnim.fps = myFullBaddieAnims[type].fps;
		modelAnim.type = type;
		myAnim.frameLoopCount = 0;
	}
	else
	{
		ASSERT(false);
	}
}

/// <summary>
/// Defines which texture in the graphics subsystem this model will use
/// </summary>		
void ModelMd2::assignTexture(TextureHandle textureID)
{
	myTextureHandle = textureID;
}

/// <summary>
/// Defines which texture in the graphics subsystem this model will use
/// </summary>		
void ModelMd2::assignBumpTexture(TextureHandle bumpTextureID, TextureHandle lightTextureID)
{
	ASSERT(bumpTextureID != UNDEFINED_TEXTURE_HANDLE);
	ASSERT(lightTextureID != UNDEFINED_TEXTURE_HANDLE);
	myBumpTextureHandle = bumpTextureID;
	myLightmapTextureHandle = lightTextureID;
}
